#include <iostream>

/*
Задание 1. Шифр Цезаря
Что нужно сделать
Юлий Цезарь использовал свой способ шифрования текста. 
Каждая буква заменялась на следующую по алфавиту через K позиций по кругу. 
Если взять английский алфавит и K = 3, то в слове, которое мы хотим зашифровать, 
буква A станет буквой D, B станет E и так далее. Если для сдвига на данное число позиций алфавита не хватает, 
то он зацикливается, то есть последняя буква алфавита Z, сдвинутая на одну позицию, будет преобразовываться в A. 

Напишите функцию encrypt_caesar, в которую передаётся текст и сдвиг и которая возвращает зашифрованный текст. 
Считаем, что входные строки состоят лишь из английских букв. Если там содержатся и другие символы, 
то их надо выдать без шифрования. Регистр букв (заглавные и строчные) меняться не должен.

Пример 1:

Text: aBxZ*

Code: 67

Результат:

pQmO*

Пример 2:

Text: The quick brown fox jumps over the lazy dog

Code: 3

Результат:

Wkh txlfn eurzq ira mxpsv ryhu wkh odcb grj

Рекомендации
Функция шифрования принимает на вход строку и смещение. Нужно добавить смещение к числовому значению очередной буквы, 
но учесть зацикленность нашего алфавита.

У английской буквы ‘A’ числовое значение 65. Вы можете узнать остальные значения при помощи 
cout << int(‘интересующая вас буква’);

То есть для получения числового значения символа добавляем одинарные кавычки. 
Чтобы проверить, попадает ли символ в диапазон, нужно сделать if(symbol >= ‘x’ && symbol <=’z’). 

Коды у заглавных и строчных символов разные. Чтобы ограничить число верхним пределом, можно воспользоваться оператором %. 

При делении с остатком на число 26 никогда не получим число больше него. 
Значит, не выйдем за пределы алфавита, а снова попадём в его начало (27 % 26 даёт 1, то есть снова первый символ). 
Чтобы зашифровать символ s, нужно:

Отнять от него значение первого символа алфавита (‘a’ или ‘A’ — вам потребуются два условия для двух разных случаев). 
Получим порядковый номер символа в алфавите. 
Добавить смещение шифра, которое указывает пользователь. 
Полученное значение разделить с остатком на 26. Получим порядковый номер символа в алфавите с учётом его зацикленности. 
Осталось получить этот символ, зная его номер. Для этого к коду первого символа алфавита (‘a’ или ‘A’) 
добавляем полученный порядковый номер.

Что оценивается
Корректность работы программы по созданию зашифрованной версии слова или текста.
*/

std::string encrypt_caesar(const std::string& text, int offset)
{
    std::string answer;
    for (const char& c : text)
    {
        char tempChar;
        if (c >= 'A' && c <= 'Z')
        {
            tempChar = char(((c - 'A') + offset) % 26 + 'A');
        } else if (c >= 'a' && c <= 'z')
        {
            tempChar = char(((c - 'a') + offset) % 26 + 'a');
        } else tempChar = c;
        answer += tempChar;
    }
    return answer;
}

int main()
{
    std::string word;
    int offset;

    std::cout << "Enter the crypt: ";
    std::getline(std::cin, word);
    std::cout << "Enter offset: ";
    std::cin >> offset;

    std::cout << "Result: " << encrypt_caesar(word, offset) << std::endl;
    return 0;
}